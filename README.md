# Рекомендательная система для Яндекс Музыки



## Описание проекта

Проект представляет собой прототип рекомендательной системы для музыкального стримингового сервиса с каталогом более 70 млн треков. Система предоставляет персонализированные рекомендации на основе истории прослушиваний ~1,4 млн пользователей и 1 млн треков.

## Этапы разработки

### Этап 1: Первичная подготовка данных
- Загрузка и оценка данных из файлов `tracks.parquet`, `catalog_names.parquet`, `interactions.parquet`
- Преобразование типов данных
- Обработка треков с неизвестными исполнителями, альбомами, жанрами

### Этап 2: Анализ данных (EDA)
- Анализ распределения количества прослушанных треков
- Выявление наиболее популярных треков и жанров
- Определение непрослушанных треков
- Сохранение подготовленных данных в `items.parquet` и `events.parquet`

### Этап 3: Офлайн-рекомендации
- Разделение данных на train/test (до 16 декабря 2022 года)
- Расчёт рекомендаций трёх типов:
  - **Топ популярных** — наиболее прослушиваемые треки
  - **Персональные (ALS)** — рекомендации на основе Alternating Least Squares
  - **Похожие треки (i2i)** — рекомендации похожих треков
- Построение ранжирующей модели с использованием минимум 3 признаков
- Оценка качества по метрикам: recall, precision, coverage, novelty

### Этап 4: Сервис рекомендаций
FastAPI микросервис для выдачи персонализированных рекомендаций в реальном времени.

## Установка и настройка окружения

### Требования
- Python 3.8+
- pandas
- numpy
- implicit (для ALS)
- FastAPI
- uvicorn
- scikit-learn

### Установка зависимостей

```bash
# Создание виртуального окружения
python3 -m venv .venv

# Активация виртуального окружения
source .venv/bin/activate

# Установка необходимых библиотек
pip install -r requirements.txt
```

## Запуск сервиса

### 1. Запуск микросервиса рекомендаций

Откройте терминал и выполните команды:

```bash
# Активация виртуального окружения
source .venv/bin/activate

# Запуск сервиса
python3 app/recommendation_service.py
```

Сервис будет доступен по адресу: `http://localhost:8000`

### 2. Запуск тестов

Откройте **новый терминал** (не закрывая первый с запущенным сервисом) и выполните:

```bash
# Активация виртуального окружения
source .venv/bin/activate

# Запуск тестов
python3 test_service.py
```

Результаты тестирования будут сохранены в файле `test_service.log`.

### 3. Просмотр результатов тестирования

```bash
cat test_service.log
```

## API Endpoints

### GET /recommendations/{user_id}

Получение персонализированных рекомендаций для пользователя.

**Параметры:**
- `user_id` (int) — идентификатор пользователя

**Пример запроса:**
```bash
curl http://localhost:8000/recommendations/12345
```

**Пример ответа:**
```json
{
  "user_id": 12345,
  "recommendations": [
    {"track_id": 67890, "score": 0.95},
    {"track_id": 54321, "score": 0.89},
    ...
  ]
}
```

## Стратегия смешивания онлайн- и офлайн-рекомендаций

Сервис использует гибридный подход для формирования итоговых рекомендаций:

### 1. Типы рекомендаций

#### Офлайн-рекомендации
- **Персональные (ALS)** — предвычисленные на основе полной истории пользователя
- **Похожие треки (i2i)** — треки, похожие на те, что слушал пользователь
- **Топ популярных** — глобально популярные треки

#### Онлайн-рекомендации
- Рекомендации на основе текущей сессии пользователя
- Учитывают последние действия в реальном времени

### 2. Логика смешивания

Система использует каскадный подход с приоритизацией:

```
1. Проверка наличия персональных рекомендаций (ALS)
   ├─ Если есть персональные + онлайн-история
   │   └─> Микс: 60% персональные + 30% онлайн + 10% популярные
   │
   ├─ Если есть персональные, но нет онлайн-истории
   │   └─> Микс: 70% персональные + 20% похожие (i2i) + 10% популярные
   │
   └─ Если нет персональных рекомендаций
       └─> Микс: 50% популярные + 50% похожие треки (i2i)
```

### 3. Ключевые принципы

- **Фильтрация истории**: Исключаются треки, которые пользователь уже прослушал
- **Диверсификация**: Обеспечивается разнообразие жанров и исполнителей
- **Новизна**: Балансируется между знакомыми и новыми треками
- **Персонализация**: Приоритет отдаётся персональным рекомендациям при их наличии
- **Cold start**: Для новых пользователей используются популярные треки и i2i рекомендации

### 4. Ранжирование

Финальное ранжирование выполняется с использованием ML-модели, которая учитывает:
- Скор от модели ALS
- Популярность трека
- Свежесть рекомендации
- Разнообразие жанров
- Совпадение с предпочтениями пользователя

## Тестирование

Скрипт `test_service.py` проверяет три сценария:

1. **Новый пользователь** — без персональных рекомендаций
2. **Пользователь с историей** — есть персональные рекомендации, но нет онлайн-сессии
3. **Активный пользователь** — есть персональные рекомендации и текущая онлайн-сессия

Результаты всех тестов сохраняются в `test_service.log` с временными метками и детальной информацией о каждом запросе.

## Метрики качества

Система оценивается по следующим метрикам:

- **Recall@K** — доля релевантных треков в топ-K рекомендациях
- **Precision@K** — точность рекомендаций
- **Coverage** — процент треков из каталога, которые попадают в рекомендации
- **Novelty** — мера новизны рекомендаций (средняя популярность рекомендованных треков)


## Автор
Roman Avanesov
Проект разработан в рамках курса по созданию рекомендательных систем.